PEP: 9999
Title: Type Stubs
Author: Jelle Zijlstra <jelle.zijlstra@gmail.com>,
 Rebecca Chen <rechen@google.com>,
 Teddy Sudol <tsudol@google.com>,
 Sebastian Rittau <srittau@rittau.biz>
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created:
Post-History:

Abstract
========

Optional type hints were introduced to the Python language in PEP 484
[#pep484]_, based on the function annotation syntax from PEP 3107
[#pep3107]_. Static type checkers can use type hints to prevent bugs,
documentation tools can automatically add type information,
and IDEs can offer improved autocompletion and support safer refactorings.

PEP 484 also introduced *type stubs*, also called *stub files*,
that provide type information for untyped Python packages and modules. Type
stubs serve multiple purposes:

* They are the only way to add type information to extension modules.
* They can provide type information for packages that do not wish to
  add them inline.
* They can be distributed separately from the implementation.
  This allows stubs to be develped at a different pace or by different
  authors, which is especially useful when adding type annotations to
  existing packages.
* They act as documentation, succinctly explaining the external
  API of a package, without including the implementation or private
  members.

This PEP aims to give guidance to both authors of type stubs and developers
of type checkers. It describes the contents of compliant type stubs,
suggests a style guide for them, and lists constructs that compliant type
checkers are expected to support.

A type stub is considered to be compliant if it only uses constructs decribed
in this PEP. Type stub authors can elect to use additional constructs, but
must be prepared that some type checkers will not parse them as expected.

A type checker is considered to be compliant if
it accepts all compliant type stubs. This means it
will parse a compliant type stub without error and does not interpret any
construct in a contradictory manner. A compliant type checker is not
required to interpret all standard constructs, and additionally a type checker
can support extra constructs not described in this PEP. All deviations from
this PEP should be documented.

Syntax
======

Type stubs are syntactically valid Python files with a ``.pyi`` suffix.
They should be valid according to the latest Python version six months
after release at the latest, but can start to use features from that
release from the release date on.
Type stubs authors are encouraged to use the latest available syntax
features in stubs, even if the type information in the stub is targeted
to an older Python version.

Type checkers are expected to support the syntax of the latest released Python
version.

For example, Python 3.7, which reserved keywords `async` and `await`
as keywords (see [#pep492]_), was released on June 27nd, 2018. Type
checkers should support them by that date and type stubs could start
using `async` to mark function definitions. Additionally, type stubs
should stop using the new keyword as an attribute or function name before
December 27nd, 2018.

Distribution
============

Type stubs can be distributed with or separately from the implementation;
see PEP 561 [#pep561]_ for more information. The typeshed_ project
includes stubs for Python's standard library and several third-party
packages. These are usually distributed with type checkers and do not
require separate installation.

Style Guide
===========

Stub files should generally follow the Style Guide for Python Code (PEP 8)
[#pep8]_. There are a few exceptions, outlined below, that take the
different structure of stub files into account and are aimed to create
more concise files.

Maximum Line Length
-------------------

Type stubs should be limited to 130 characters per line.

Blank Lines
-----------

Do not use empty lines between functions, methods, and fields, except to
group them with one empty line. Use one empty line around classes, but do not
use empty lines between body-less classes, except for grouping.

Yes::

    def time_func() -> None: ...
    def date_func() -> None: ...

    def ip_func() -> None: ...

    class Foo:
        x: int
        y: int
        def __init__(self) -> None: ...

    class MyError(Exception): ...
    class AnotherError(Exception): ...

No::

    def time_func() -> None: ...

    def date_func() -> None: ...  # do no leave unnecessary empty lines

    def ip_func() -> None: ...


    class Foo:  # leave only one empty line above
        x: int
    class MyError(Exception): ...  # leave an empty line between the classes

Module Level Attributes
-----------------------

Do not use an assignment for module-level attributes.

Yes::

    CONST: str
    x: int

No::

    CONST = ""
    x: int = 0
    y: float = ...
    z = 0  # type: int
    a = ...  # type: int

Classes
-------

Do not include docstrings in class bodies.

Classes without bodies should use the ellipsis operator ``...`` in place
of the body on the same line as the class definition.

Yes::

    class MyError(Exception): ...

No::

    class MyError(Exception):
        ...
    class AnotherError(Exception): pass

Functions and Methods
---------------------

The bodies of functions and methods should consist of only the ellipsis
operator ``...`` on the same line as the closing parenthesis and colon.
Do not include docstrings.

Yes::

    def to_int1(x: str) -> int: ...
    def to_int2(
        x: str,
    ) -> int: ...

No::

    def to_int1(x: str) -> int:
        return int(x)
    def to_int2(x: str) -> int:
        ...
    def to_int3(x: str) -> int: pass

Use the ellipsis operator ``...`` in place of actual default argument
values. Use an explicit ``Optional`` annotation instead of
a ``None`` default.

Yes::

    def foo(x: int = ...) -> None: ...
    def bar(y: Optional[str] = ...) -> None: ...

No::

    def foo(x: int = 0) -> None: ...
    def bar(y: str = None) -> None: ...
    def baz(z: Optional[str] = None) -> None: ...

Private Definitions
-------------------

Type variables, type aliases, and other other definitions that should not
be used outside the stub should be marked as private by prefixing them
with an underscore.

Yes::

    _T = TypeVar("_T")
    _DictList = Dict[str, List[Optional[int]]]

No::

    T = TypeVar("T")
    DictList = Dict[str, List[Optional[int]]]

If a function or method returns an instance of a class that is not
available at runtime, the type stub should provide a public, stub-only class::

    # Only available during type checking
    class SomeData:
        x: int
        def foo() -> None: ...

    def get_some_data() -> SomeData: ...

Language Features
-----------------

Use the latest language features available as outlined
in the Syntax_ section, even for stubs targeting older Python versions.
Do not use quotes around forward references and do not use ``__future__``
imports.

Yes::

    class Py35Class:
        x: int
        forward_reference: OtherClass
    class OtherClass: ...

No::

    class Py35Class:
        x = 0  # type: int
        forward_reference: 'OtherClass'
    class OtherClass: ...

Types
-----

Use ``float`` instead of ``Union[int, float]``. For argument types,
use ``bytes`` instead of ``Union[bytes, memoryview, bytearray]``.

Use ``Text`` in stubs that support Python 2 when something accepts both
``str`` and ``unicode``. Avoid using ``Text`` in stubs or branches for
Python 3 only.

Yes::

    if sys.version_info < (3,):
        def foo(s: Text) -> None: ...
    else:
        def foo(s: str, *, i: int) -> None: ...
    def bar(s: Text) -> None: ...

No::

    if sys.version_info < (3,):
        def foo(s: unicode) -> None: ...
    else:
        def foo(s: Text, *, i: int) -> None: ...

Prefer protocols and abstract types (``Mapping``, ``Sequence``, ``Iterable``,
etc.) for arguments. Prefer concrete types (``List``, ``Dict``, etc.) for
return values of concrete implementations. The return values of protocols
and abstract base classes must be judged on a case-by-case basis.

Yes::

    def map_it(input: Iterable[str]) -> List[int]: ...
    def create_map() -> Dict[str, int]: ...

No::

    def map_it(input: List[str]) -> List[int]: ...
    def create_map() -> MutableMapping[str, int]: ...

Maybe::

    class MyProto(Protocol):
        def foo(self) -> List[int]: ...
        def bar(self) -> Mapping[str]: ...

Avoid ``Union`` return types, since they require ``isinstance()`` checks.
Use ``Any`` if necessary.

References
==========

.. [#pep8] PEP 8 -- Style Guide for Python Code, van Rossum et al. (https://www.python.org/dev/peps/pep-0008/)
.. [#pep484] PEP 484 -- Type Hints, van Rossum et al. (https://www.python.org/dev/peps/pep-0484)
.. [#pep492] PEP 492 -- Coroutines with async and await syntax, Selivanov (https://www.python.org/dev/peps/pep-0492/)
.. [#pep526] PEP 526 -- Syntax for Variable Annotations, Gonzalez et al. (https://www.python.org/dev/peps/pep-0526)
.. [#pep561] PEP 561 -- Distributing and Packaging Type Information, Smith (https://www.python.org/dev/peps/pep-0561)
.. [#pep3107] PEP 3107 -- Function Annotations, Winter and Lownds (https://www.python.org/dev/peps/pep-3107)

.. _typeshed: https://github.com/python/typeshed

Copyright
=========

This document has been placed in the public domain.
